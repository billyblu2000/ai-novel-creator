# 里程碑一：奠定基石 (Project & Story Base)

目标： 搭建应用的基础骨架，让用户可以创建小说项目，并为其填充核心的世界观和角色设定。此阶段完全不涉及AI。

## 第一阶段：小说项目管理 (Project CRUD)

- 后端:
[数据库] 完善 Prisma 中的 Project 模型，可以增加 description 等字段。
[API] 创建完整的 RESTful API 用于项目的增、删、改、查 (POST /projects, GET /projects, GET /projects/:id, PUT /projects/:id, DELETE /projects/:id)。

- 前端:
[页面] 创建一个主仪表盘页面 (Dashboard.tsx)，用于展示所有小说项目。
[组件] 创建一个 ProjectList 组件，从后端获取并渲染项目列表。
[功能] 实现一个“创建新项目”的弹窗或页面，让用户可以输入标题和简介。
[路由] 设置路由，允许用户点击某个项目，进入该项目的详情页（目前可以是空白页）。


## 第二阶段：故事基座 (Story Base CRUD)

- 后端:
[数据库] 在 schema.prisma 中创建 Character（角色）、WorldSetting（世界观设定）、Outline（大纲）等模型。确保它们都与 Project 模型关联（例如，一个 Project 可以有多个 Character）。
[数据库] 运行 npx prisma db push 更新数据库结构。
[API] 为 Character, WorldSetting, Outline 分别创建各自的增、删、改、查 API。

- 前端:
[页面布局] 在项目详情页内，设计一个标签页或侧边栏导航，分别指向“世界观”、“角色卡”、“故事大纲”等管理模块。
[功能] 为每个模块实现对应的界面。例如，在“角色卡”模块，用户可以查看所有角色，并可以新建、编辑或删除角色（包含姓名、性格、背景故事等字段的表单）。


# 里程碑二：核心创作体验与AI的首次登场

目标： 实现小说的核心写作功能，并集成最关键的AI能力——基于“故事基座”的上下文感知续写。

## 第三阶段：章节编辑器 (Writing Editor)

- 后端:
[数据库] 创建 Chapter 模型，包含 title、content 和与 Project 的关联。
[API] 创建 Chapter 的增、删、改、查 API，特别是用于“保存/加载”章节内容的 API。

- 前端:
[页面布局] 在项目详情页，创建一个“写作”或“正文”的主区域。
[组件] 集成一个富文本编辑器库（例如 TipTap 或 Quill.js），作为用户的写作界面。
[功能] 实现章节列表，用户可以创建新章节、切换章节。编辑器内容应能自动或手动保存到后端。

## 第四阶段：AI核心循环 (RAG - Retrieval-Augmented Generation)

- 后端:
[服务] 创建一个 VectorDBService.ts，封装与 LanceDB 交互的逻辑（初始化、添加文档、搜索）。
[服务] 创建一个 EmbeddingService.ts，封装调用 OpenAI Embedding API 的逻辑。
[逻辑] 关键逻辑： 当用户在第二阶段创建或更新角色/世界观时，自动触发一个流程：文本 -> 调用 EmbeddingService -> 获得向量 -> 调用 VectorDBService 存入 LanceDB。
[API] 创建一个核心的 AI 生成 API，例如 POST /api/generate/continue。这个 API 的内部流程是：
a. 接收前端传来的当前章节末尾的文本。
b. 将这段文本向量化。
c. 在 LanceDB 中搜索最相关的“故事基座”信息（角色、设定等）。
d. (提示词工程) 将检索到的上下文信息、当前文本、以及一个预设的指令（如“请根据以下背景资料和上文，自然地续写故事：”）组合成一个丰富的 Prompt。
e. 调用 OpenAI 的 completions API。
f. 将结果以流式（streaming）或非流式的方式返回给前端。

- 前端:
[功能] 在编辑器中，添加一个“AI续写”按钮。
[交互] 点击按钮时，获取当前光标前的部分文本，调用后端的 /api/generate/continue API，并将返回的AI生成内容插入到编辑器中。

# 里程碑三：智能化增强与体验优化

目标： 您的应用已经成为一个可用的“AI小说家”了。现在我们要让它变得更“智能”，更懂你的创作。

## 第五阶段：智能辅助工具

- 后端 & 前端:
[功能] 情景对话生成器： 创建一个专用工具界面。用户选择 2-3 个已创建的角色，输入一个情景主题。后端获取这些角色的性格、背景信息，构建一个专门的 Prompt（“请模拟以下角色进行一段关于...的对话，注意他们的性格和口吻：...”）来生成高质量对话。
[功能] 大纲/情节头脑风暴： 在“故事大纲”模块，用户可以选中一个大纲节点，请求 AI “提供三种可能的情节走向”或“ fleshing out this plot point”。
[功能] “@”唤醒上下文： 这是一个高级功能。在前端编辑器中，当用户输入“@”时，弹出一个列表，显示项目中的所有角色和关键设定。用户选择后，可以将该信息作为优先上下文，传递给AI。

## 第六阶段：一致性与审阅

- 后端 & 前端:
[功能] 一致性检查器 (AI "Editor")： 创建一个“审阅本章”功能。后端接收整个章节的文本，将其分块后，对每个块进行向量化，然后检查这些块是否与“故事基座”中的核心设定（例如主角的关键背景）存在潜在冲突。在前端高亮显示可能的矛盾之处。
[功能] 伏笔追踪： 允许用户在写作时，手动标记某句话为“伏笔”。这些伏笔会被单独记录。在后续写作中，用户可以随时查看尚未“回收”的伏笔列表。


# 里程碑四：产品化与高级功能

目标： 将应用从一个强大的个人工具，转变为一个可以分享、更具吸引力的产品。

## 第七阶段：多模态与导出

- 后端 & 前端:
[功能] AI插画： 集成图像生成API（如 DALL-E 3 或 Stable Diffusion）。用户可以选中一段场景描述，请求AI为其生成概念插图。
[功能] 导出功能： 实现将整部小说导出为 TXT、Markdown 或 PDF 格式。

## 第八阶段：用户系统与部署

- 后端 & 前端:
[功能] 用户认证： 如果计划让其他人使用，这是必需的一步。可以集成 Clerk、Supabase Auth 或 NextAuth.js 等服务，快速实现用户注册和登录。
[数据库] 将所有模型（Project, Character 等）与 User 模型关联。
[部署] 准备部署。将前端部署到 Vercel/Netlify，后端部署到 Railway/Fly.io 等平台。编写部署文档。